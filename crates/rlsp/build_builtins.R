#!/usr/bin/env Rscript

# Extract all function names from base R packages
packages <- c("base", "stats", "utils", "graphics", "grDevices", "methods", "datasets")

all_functions <- character()

for (pkg in packages) {
  tryCatch({
    funcs <- ls(paste0("package:", pkg))
    # Filter to only actual functions
    funcs <- funcs[sapply(funcs, function(f) {
      obj <- get(f, envir = as.environment(paste0("package:", pkg)))
      is.function(obj) || is.primitive(obj)
    })]
    all_functions <- c(all_functions, funcs)
  }, error = function(e) {
    warning(paste("Could not load package:", pkg))
  })
}

# Remove duplicates and sort
all_functions <- sort(unique(all_functions))

cat("Found", length(all_functions), "functions\n")

# Generate Rust source file
rust_code <- c(
  "//",
  "// builtins.rs",
  "// Auto-generated by build_builtins.R",
  "//",
  "",
  "use std::collections::HashSet;",
  "use std::sync::OnceLock;",
  "",
  "static BUILTINS: OnceLock<HashSet<&'static str>> = OnceLock::new();",
  "",
  "pub fn is_builtin(name: &str) -> bool {",
  "    let builtins = BUILTINS.get_or_init(|| {",
  "        let mut set = HashSet::new();"
)

# Add all function names
for (func in all_functions) {
  # Escape special characters for Rust string
  escaped <- gsub("\\", "\\\\", func, fixed = TRUE)
  escaped <- gsub("\"", "\\\"", escaped, fixed = TRUE)
  rust_code <- c(rust_code, paste0("        set.insert(\"", escaped, "\");"))
}

rust_code <- c(
  rust_code,
  "        set",
  "    });",
  "    builtins.contains(name)",
  "}"
)

# Write to file
output_file <- "src/builtins.rs"
writeLines(rust_code, output_file)

cat("Generated", output_file, "with", length(all_functions), "functions\n")
